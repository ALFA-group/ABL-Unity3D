using System;
using System.Collections.Generic;
using ABLUnitySimulation;
using ABLUnitySimulation.Actions.Helpers;
using Newtonsoft.Json;
using Sirenix.OdinInspector;
using Sirenix.Serialization;
using UnityEngine;
using UnityEngine.Serialization;

#nullable enable

namespace Planner
{
    [HideReferenceObjectPicker]
    public class PlannerParameters
    {
        /// <summary>
        ///     The goal for the planner to achieve.
        /// </summary>
        /// <remarks>
        ///     We assign concrete values to each enum because it helps with serialization,
        ///     in particular if we remove or add another value.
        /// </remarks>
        public enum PlannerGoal
        {
            AttackCircle = 2,
            ClearAllEnemies = 3,
            NProngs = 4 
        }
        
        // ReSharper disable once UnusedMember.Local
        private bool ShouldShowWaypointsAsCapsuleColliders => 
            this.pureData.goal is PlannerGoal.NProngs or PlannerGoal.AttackCircle &&
            !this.pureData.showOnlyCircleCache;

        protected bool IsNProngs => this.pureData.goal == PlannerGoal.NProngs;
        
        [HideReferenceObjectPicker]
        public class PlannerParametersWaypointsAsCapsuleColliders
        {
            /// <summary>
            ///     The circle that must be cleared by the end of NProngs.
            /// </summary>
            /// <remarks>
            ///     It is not safe to use this after running an experiment. If after an experiment is run the position
            ///     of this capsule collider is changed in the scene, then the waypoint will not be the same as when the
            ///     experiment is initially run. Only use <see cref="PlannerParametersPureData.goalWaypointAsCircleCache"/> for experiments
            ///     after serialization.
            /// </remarks>
            [LabelText("Goal Waypoint")]
            public CapsuleCollider? goalWaypointAsCapsuleCollider;

            /// <summary>
            ///     Waypoints to be used as a options for NProngs.
            /// </summary>
            /// <remarks>
            ///     It is not safe to use these after running an experiment. If after an experiment is run the positions
            ///     of the capsule colliders in the scene change, then the waypoints will not be the same as when the
            ///     experiment is initially run. Only use <see cref="PlannerParametersPureData.waypointOptionsAsCirclesCache"/> for experiments
            ///     after serialization.
            /// </remarks>
            [LabelText("Waypoint Options")]
            public List<CapsuleCollider> waypointOptionsAsCapsuleColliders = new List<CapsuleCollider>();

            public PlannerParametersWaypointsAsCapsuleColliders DeepCopy()
            {
                return new PlannerParametersWaypointsAsCapsuleColliders
                {
                    goalWaypointAsCapsuleCollider = this.goalWaypointAsCapsuleCollider,
                    waypointOptionsAsCapsuleColliders = this.waypointOptionsAsCapsuleColliders
                };
            }
        }

        [HideReferenceObjectPicker]
        public class PlannerParametersPureData
        {
            [HideInInspector]
            public bool showOnlyCircleCache = false;

            /// <summary>
            ///     When true, removes enemy SimActions (except Opportunity Fire) from the simulator world state before planing.
            ///     This is useful in planning so that the friendly team won't magically know what the enemy team is going to do.
            /// </summary>
            [Tooltip("When true, we remove enemy SimActions before planning so that the " +
                     "friendly team can't read their minds (except opportunity fire")]
            public bool stripEnemyActions;

            /// <summary>
            ///     The maximum number of plans to store.
            /// </summary>
            [MinValue(1)]
            public int maxNumberOfPlansKept = 100;

            /// <summary>
            ///     The maximum number of plans that can be generated by the Planner.
            /// </summary>
            [MinValue(1)]
            public int maxNumberOfPlansCreated = 1000;

            /// <summary>
            ///     The number of seconds to simulate per simulator step. This affects only planning, not visualization of plans.
            /// </summary>
            [MinValue(1)]
            public int secondsPerSimStep = 20;

            /// <summary>
            ///     The maximum number of seconds to simulate in a single simulation.
            /// </summary>
            [MinValue(1)]
            [FormerlySerializedAs("sMaxExecutionTime")]
            public int maxExecutionTimeInSeconds = 20000;

            public bool multiThread = true;

            /// <summary>
            ///     Whether the planner should stop running after <see cref="timeLimitInSeconds" /> seconds have elapsed.
            ///     A.k.a should the planner timeout.
            /// </summary>
            public bool shouldTimeout;

            /// <summary>
            ///     The amount of time the planner should timeout after.
            ///     Only happens if <see cref="shouldTimeout" /> is set to true.
            /// </summary>
            [ShowIf("@shouldTimeout == true"), MinValue(1), Indent]
            public int timeLimitInSeconds = 10000;

            #region GOAL_PARAMETERS
            /// <summary>
            ///     The goal used by the planner.
            /// </summary>
            [MinValue(1),
             MaxValue("@Enum.GetNames(typeof(PlannerGoal)).Length")]
            public PlannerGoal goal = PlannerGoal.NProngs;

            /// <summary>
            ///     The number of prongs to use for <see cref="PlannerGoal.NProngs" />
            /// </summary>
            [MinValue(1)]
            
            // [MaxValue("@this.waypointsAsCapsuleColliders.waypointOptionsAsCapsuleColliders.Count")]
            [ShowIf("@this.goal == PlannerGoal.NProngs")]
            [Indent]
            public int numProngs = 3;

            /// <summary>
            ///     The team to plan for.
            /// </summary>
            [Indent]
            public Team activeTeam = Team.Red;

            /// <summary>
            ///     List of waypoints as options for NProngs converted to circles.
            /// </summary>
            /// <remarks>
            ///     This is useful for when you need to convert the goal waypoint to a circle when not
            ///     on the main thread. When not on the main thread, you cannot access Unity transform methods
            ///     and fields, which are necessary to convert the Unity capsules to circles. In addition,
            ///     it is also useful for serialization purposes. When saving results for an experiment,
            ///     you want to make sure the goal waypoint position remains the same regardless if the scene
            ///     is modified. Therefore, we convert the goal waypoint from a capsule collider to a circle,
            ///     which do not change if the goal waypoint (<see cref="PlannerParametersWaypointsAsCapsuleColliders.waypointOptionsAsCapsuleColliders"/>)
            ///     changes.
            /// </remarks>
            [OdinSerialize]
            [ShowIf("$showOnlyCircleCache")]
            [Indent]
            [HideReferenceObjectPicker]
            [HideDuplicateReferenceBox]
            public Circle? goalWaypointAsCircleCache;

            /// <summary>
            ///     List of waypoints as options for NProngs converted to circles.
            /// </summary>
            /// <remarks>
            ///     This is useful for when you need to convert the waypoint capsules to circles when not
            ///     on the main thread. When not on the main thread, you cannot access Unity transform methods
            ///     and fields, which are necessary to convert the Unity capsules to circles. In addition,
            ///     it is also useful for serialization purposes. When saving results for an experiment,
            ///     you want to make sure the waypoint positions remain the same regardless if the scene
            ///     is modified. Therefore, we convert the waypoints from capsule colliders to circles,
            ///     which do not change if the waypoint capsule colliders (<see cref="PlannerParametersWaypointsAsCapsuleColliders.waypointOptionsAsCapsuleColliders"/>)
            ///     change.
            /// </remarks>

            [OdinSerialize]
            [ShowIf("$showOnlyCircleCache")]
            [Indent]
            [HideReferenceObjectPicker]
            [HideDuplicateReferenceBox]
            public List<Circle>? waypointOptionsAsCirclesCache;
            #endregion GOAL_PARAMETERS

            public PlannerParametersPureData DeepCopy()
            {
                return new PlannerParametersPureData
                {
                    stripEnemyActions = this.stripEnemyActions,
                    activeTeam = this.activeTeam,
                    goal = this.goal,

                    maxNumberOfPlansCreated = this.maxNumberOfPlansCreated,
                    maxNumberOfPlansKept = this.maxNumberOfPlansKept,
                    multiThread = this.multiThread,
                    numProngs = this.numProngs,
                    secondsPerSimStep = this.secondsPerSimStep,
                    maxExecutionTimeInSeconds = this.maxExecutionTimeInSeconds,

                    shouldTimeout = this.shouldTimeout,
                    timeLimitInSeconds = this.timeLimitInSeconds,
                    waypointOptionsAsCirclesCache = this.waypointOptionsAsCirclesCache,
                    goalWaypointAsCircleCache = this.goalWaypointAsCircleCache,
                    showOnlyCircleCache = this.showOnlyCircleCache,
                };
            }
        }
        
        [OdinSerialize]
        [HideLabel]
        public PlannerParametersPureData pureData = new PlannerParametersPureData();


        [OdinSerialize]
        [ShowIf("$ShouldShowWaypointsAsCapsuleColliders")]
        [HideLabel]
        [Indent]
        [OnStateUpdate("@#(waypointsAsCapsuleColliders.waypointOptionsAsCapsuleColliders).State.Visible = this.pureData.goal == PlannerGoal.NProngs")]
        public PlannerParametersWaypointsAsCapsuleColliders waypointsAsCapsuleColliders =
            new PlannerParametersWaypointsAsCapsuleColliders();

        public PlannerParameters DeepCopy()
        {
            return new PlannerParameters
            {
                pureData = this.pureData.DeepCopy(),
                waypointsAsCapsuleColliders = this.waypointsAsCapsuleColliders.DeepCopy()
            };
        }
    }
}